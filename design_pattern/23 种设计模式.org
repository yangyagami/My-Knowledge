#+TITLE: 23 种设计模式
#+DATE: <2025-03-10 一>
#+AUTHOR: yangsiyu
* 总览
- Abstract Factory
  提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。
- Adapter
  将一个类的接口转换成客户希望的另外一个接口。
  Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
- Bridge
  将抽象部分与它的实现部分分离，使它们都可以独立地变化。
- Builder
  将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
- Chain of Responsibility
  解除请求的发送者和接收者之间的耦合，使多个对象都有机会处理这个请求。
  将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。
- Command
  将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。
- Composite
  将对象组合成树形结构以表示“部分–整体”的层次结构。Composite使得客户对单个对象和组合对象的使用具有一致性。
- Decorator
  动态地给一个对象添加一些额外的职责。就扩展功能而言，Decorator模式比生成子类方式更为灵活。
- Facade (外观)
  为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
- Factory Method
  定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method使一个类的实例化延迟到其子类。
- Flyweight
  运用共享技术有效地支持大量细粒度的对象。
- Interpreter
  给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。
- Iterator
  提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。
- TODO... [[https://weread.qq.com/web/reader/0eb32540813ab9066g019237][23 种设计模式]]

* 分类
[[https://weread.qq.com/web/reader/0eb32540813ab9066g019237kc51323901dc51ce410c121b][设计模式分类]]
根据 *目的* ，可将设计模式分为创建型、结构性、行为型。
- 创建型模式与对象的创建有关；
- 结构型模式处理类或对象的组合；
- 行为型模式对类或对象怎样交互和怎样分配职责进行描述。

根据 *范围* ，指定模式主要是用于类还是对象。
- 类模式处理类和子类之间的关系，这些关系通过继承建立，是静态的，在编译时便确定下来了。
- 对象模式处理对象间的关系，这些关系在运行时是可以变化的，更具动态性。
从某种意义上来说，几乎所有模式都使用继承机制，所以“类模式”只指那些集中于处理类间关系的模式，而大部分模式都属于对象模式的范畴。

- 创建型类模式将对象的部分创建工作延迟到子类。创建型对象模式则将它延迟到另一个对象中。
- 结构型类模式使用继承机制来组合类，而结构型对象模式则描述了对象的组装方式。
- 行为型类模式使用继承描述算法和控制流，而行为型对象模式则描述了一组对象怎样协作完成单个对象所无法完成的任务。
