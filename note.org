* C++ 读取文件内容到容器里
[2025-06-10 二 17:09]
#+BEGIN_SRC C++
std::string inputBuffer((std::istreambuf_iterator<char>(file)),
                          std::istreambuf_iterator<char>());
#+END_SRC

* qml 监听并且设置快捷键
[2025-06-11 三 15:57]
#+BEGIN_SRC qml
  Button {
      id: toggleWakeup
      anchors.right: parent.right
      anchors.verticalCenter: parent.verticalCenter
      text: "点击我或按 Ctrl+S"
      onClicked: {
  	toggleWakeup.text = "按钮被点击或 Ctrl+S 被按下";
      }

      Keys.onPressed: {
  	if (event.modifiers & Qt.ControlModifier && event.key === Qt.Key_S) {
  	    toggleWakeup.text = "你按下了 Ctrl+S";
  	    event.accepted = true;
  	}
      }
  }  // Button($toggleWakeup)
=======
* HTML 创建按钮，并且监听 onclick 事件
[2025-05-15 Thu 10:51]
#+BEGIN_SRC js
  const button = document.createElement('button');
  button.innerText = '带我去';

  button.onclick = function() {
      
  };
#+END_SRC

* HTML CSS 隐藏滚动条
[2025-05-15 Thu 14:13]
#+BEGIN_SRC css
  /* 隐藏滚动条 */
  .chat-container::-webkit-scrollbar {
      display: none; /* 对于 WebKit 浏览器（Chrome, Safari） */
  }
#+END_SRC

* std::shared_ptr 模板参数不用带星号。
[2025-05-18 Sun 10:44]
#+BEGIN_SRC C++
std::shared_ptr<BaiduFaceApi> api_ = nullptr;
#+END_SRC

* shared_ptr 这样构造。
[2025-05-18 Sun 10:49]
#+BEGIN_SRC C++
api_ = std::make_shared<BaiduFaceApi>();
#+END_SRC

* QRect 设置 Rect 。
[2025-05-18 Sun 13:14]
#+BEGIN_SRC C++
  stImageResult.face_rgb_rect.setRect(
      faces[0].left,
      faces[0].top,
      faces[0].right,
      faces[0].bottom);
#+END_SRC

* QDir::homePath
非 windows 系统下，使用 HOME 环境变量获取。

* QT 绘制无线信号
[2025-05-22 Thu 15:58]
#+BEGIN_SRC C++
  #ifndef RK3588_WIFI_WIFI_DELEGATE_H_
  #define RK3588_WIFI_WIFI_DELEGATE_H_

  #include <QStyledItemDelegate>
  #include <QPainter>
  #include <QDebug>
  #include <QPainterPath>

  #include "wifi_model.h"

  class RK3588WifiDelegate : public QStyledItemDelegate {
   public:
    using QStyledItemDelegate::QStyledItemDelegate;

    // 自定义绘制函数
    void paint(QPainter* painter,
               const QStyleOptionViewItem& option,
               const QModelIndex& index) const override {

      painter->save();

      painter->setRenderHint(QPainter::Antialiasing);

      // painter->translate(option.rect.topLeft());

      // 高亮选中项的背景
      if (option.state & QStyle::State_Selected) {
        painter->fillRect(option.rect, QColor("#e3f2fd")); // 浅蓝色背景
      }

      // 绘制文本（左对齐，垂直居中）
      QFont font;

      font.setPointSize(12);

      painter->setFont(font);

      QString text = index.data(RK3588WifiModel::kSSID).toString();
      QRect textRect = option.rect.adjusted(5, 0, -5, 0); // 左右留空5像素

      painter->setPen(Qt::black);
      painter->drawText(textRect, Qt::AlignLeft | Qt::AlignVCenter, text);

      DrawWifi(painter, option, index);

      painter->restore();
    }

    // 设置项的理想大小
    QSize sizeHint(const QStyleOptionViewItem& option,
                   const QModelIndex& index) const override {
      return QSize(option.widget->width(), 80);
    }

   private:
    void DrawWifiArc(QPainter* painter, int radius, int arc_height,
                     bool sub = true) const {
      // Center rect. radius = rect.width / 2; also as circle's radius.
      QRectF rect(-radius, -radius, radius << 1, radius << 1);

      QPainterPath path;
      path.arcTo(rect, 45, 90);

      QPainterPath subPath;
      subPath.addEllipse(
          rect.adjusted(arc_height, arc_height, -arc_height, -arc_height));

      if (sub) {
        path -= subPath;
      }
      painter->drawPath(path);
    }

    void DrawWifi(QPainter* painter,
                  const QStyleOptionViewItem& option,
                  const QModelIndex& index) const {
      int signal = index.data(RK3588WifiModel::kSignal).toInt();

      QRect wifi_rect = option.rect.adjusted(
          option.rect.width() - 120,
          20,
          -90,
          -20);

      const int kMaxItem = 4;

      const int kRadius = wifi_rect.height() * 0.88;
      const int kArcHeight = wifi_rect.height() / 10.5;

      for (int i = 0; i < kMaxItem; ++i) {
        if (signal >= i) {
          // Has signal
          painter->setPen(Qt::black);
          painter->setBrush(Qt::black);
        } else {
          painter->setPen(QColor(200, 200, 200));
          painter->setBrush(QColor(200, 200, 200));
        }

        switch (i) {
          case 0: {
            painter->translate(
                QPointF(wifi_rect.x() + wifi_rect.width() * 0.5,
                        wifi_rect.y() + wifi_rect.height() * 0.95));
            DrawWifiArc(painter, kRadius * 0.15, kArcHeight, false);
            break;
          }
          case 1:
            DrawWifiArc(painter, kRadius * 0.4, kArcHeight);
            break;
          case 2:
            DrawWifiArc(painter, kRadius * 0.7, kArcHeight);
            break;
          case 3:
            DrawWifiArc(painter, kRadius, kArcHeight);
            break;
        }
      }
    }
  };

  #endif  // RK3588_WIFI_WIFI_DELEGATE_H_
#+END_SRC

* QT 遍历 QJsonArray
[2025-05-25 Sun 11:25]
#+BEGIN_SRC C++
  QJsonArray json_array = doc.array();
  for (const QJsonValue &value : json_array) {
      qDebug() << value; // 处理每个值
  }
#+END_SRC

* QT 图像被莫名翻转
[2025-05-25 Sun 17:09]
#+BEGIN_SRC C++
  // 图片文件（如 JPEG）可能包含 EXIF 方向标签（Orientation Tag），部分图像库（如 Qt 的默认图像加载器）不会自动处理此信息，导致图像显示时方向错误。
QImageReader reader(path);
  reader.setAutoTransform(true); // 启用自动 EXIF 方向校正
  QImage image = reader.read();
#+END_SRC

* QT 信号重载
[2025-05-27 Tue 11:54]
#+BEGIN_SRC C++
  connect(ws_, QOverload<QAbstractSocket::SocketError>::of(&QWebSocket::error),
  [this](QAbstractSocket::SocketError error){
              QString error_str =
                  QMetaEnum::fromType<QAbstractSocket::SocketError>()
                  .valueToKey(error);
              logger_.Error(QString("Network error: %1").arg(error_str));
              emit AiControllerStatusNotify(static_cast<int>(error) + 7000,
                                            "Network error.");
            });
#+END_SRC

* C++ 计算经过时间
[2025-06-02 Mon 12:35]
#+BEGIN_SRC C++
  auto start = std::chrono::high_resolution_clock::now();
  player.Write(buffer, 3000ms);
  auto end = std::chrono::high_resolution_clock::now();
  // 计算持续时间
  std::chrono::duration<double> duration = end - start;

  // 输出执行时间（秒）
  std::cout << "执行时间: " << duration.count() << " 秒" << std::endl;
#+END_SRC

* QT 读取目录下的文件
[2025-06-16 一 14:16]
#+BEGIN_SRC C++
  QDir dir("/usr/share/applications");
  if (!dir.exists()) {
    qDebug() << "目录不存在";
    return -1;
  }

  QStringList filters;
  filters << "*.desktop"; // 只处理 .desktop 文件
  QFileInfoList files = dir.entryInfoList(filters, QDir::Files);

  QVector<DesktopFile*> desktop_files;

  for (const QFileInfo &fileInfo : files) {
    qDebug() << "解析文件:" << fileInfo.filePath();
    DesktopFile *desktopfile = new DesktopFile;
    if (desktopfile->Parse(fileInfo.filePath())) {
      desktop_files.push_back(desktopfile);
    }
  }
#+END_SRC

* qml listview 自动滚动
[2025-06-18 三 14:17]
#+BEGIN_SRC qml
  ListView {
      id: listmodelId
      width: parent.width
      height: parent.height * 0.6

      clip: true

      onCountChanged: Qt.callLater(scrollToBottom)

      function scrollToBottom() {
    	    if (count > 0) {
    		positionViewAtEnd()
    	    }
      }

      onContentHeightChanged: Qt.callLater(scrollToBottom)  // 滚动时这个也会变化

      spacing: 10
      model: g_chatWindowModel.chatModel
      delegate: CusItemRect {
    	    id: cusitemRectid

    	    itemImgemodel: chatMsgImage
    	    msgText: chatMsgConten
    	    itemUrlmodel: chatMsgUrl
    	    isSelf: chatMsgIsSelf

    	    onHeightChanged: {
    		listmodelId.scrollToBottom()
    	    }
      }

      ScrollBar.vertical: ScrollBar {
    	id: vbar
    	policy: ScrollBar.AsNeeded
    	width: 10

    	contentItem: Rectangle {
              implicitWidth: 6
              radius: 4
              color: vbar.pressed ? "#6c6c6c" : (vbar.hovered ? "#9a9a9a" : "#c4c4c4")
              Behavior on color {
    		ColorAnimation {
                      duration: 100
    		}  // ColorAnimation
              }
    	}  // Rectangle

    	background: Rectangle {
              implicitWidth: 10
              color: "#f0f0f0"
    	}  // Rectangle
      }  // ScrollBar($vbar)
  }  // ListViw($listmodelId)

  // 控制是否自动滚动（例如用户手动滚动时禁用）
  property bool autoScroll: true

  function scrollToBottom() {
      if (autoScroll && count > 0) {
          positionViewAtEnd()
      }
  }

  // 用户交互时暂停自动滚动
  onMovementStarted: autoScroll = false
  onMovementEnded: {
      // 如果在底部附近则恢复自动滚动
      autoScroll = (contentY >= contentHeight - height - 20)
  }
#+END_SRC

* CMake 根据构建模式来设置不同的编译选项
[2025-06-20 五 14:20]
#+BEGIN_SRC cmake
  target_compile_options(${PROJECT_NAME} PRIVATE
    -Wall -Wextra
    $<$<CONFIG:Debug>:-O0>
    $<$<CONFIG:Release>:-O2>
  )

  target_link_libraries(${PROJECT_NAME}
    PRIVATE Qt${QT_VERSION_MAJOR}::Core Qt${QT_VERSION_MAJOR}::Quick Qt${QT_VERSION_MAJOR}::Multimedia Qt${QT_VERSION_MAJOR}::Network
    $<$<CONFIG:Debug>:-fsanitize=address>)
  #+END_SRC

* Qt invokeMethod 使用示例
[2025-06-20 五 14:31]
#+BEGIN_SRC C++
  QMetaObject::invokeMethod(dynamic_cast<PrinterFinderWorker*>(worker_),
                            &PrinterFinderWorker::GetPrinterInfoList);
#+END_SRC

* 热重载 qml 的方法，以及可分别设置圆角方法（Qt5)
[2025-06-21 六 18:43]
#+BEGIN_SRC qml
  使用 qmlpreview
  Window {
      width: 640
      height: 800
      visible: true
      title: qsTr("Hello World")
      flags: Qt.FramelessWindowHint | Qt.WindowStaysOnTopHint | Qt.Popup

      Canvas {
  	id: canvas
  	width: parent.width - 40
  	height: 60
  	x: 20
  	y: 80
  	property var color: Qt.rgba(0, 1, 1, 1)
  	property var radius: [20, 20, 0, 0]  // topLeft topRight bottomLeft bottomRight
  	onPaint:{
              var ctx = canvas.getContext("2d")

  	    ctx.beginPath(); 
  	    ctx.moveTo(0, radius[2]);
  	    ctx.lineTo(0, height - radius[2]);
  	    ctx.arcTo(0, height, radius[2], height, radius[2])
  	    ctx.lineTo(width - radius[3], height)
  	    ctx.arcTo(width, height, width, height - radius[3], radius[3])
  	    ctx.lineTo(width, radius[1])
  	    ctx.arcTo(width, 0, width - radius[1], 0, radius[1])
  	    ctx.lineTo(radius[0], 0)
  	    ctx.arcTo(0, 0, 0, radius[0], radius[0])
  	    ctx.fillStyle = color
  	    ctx.fill();
  	}
      }
  }
#+END_SRC

* Qt model setData 例子
[2025-06-26 四 10:45]
#+BEGIN_SRC C++
  bool setData(const QModelIndex &index, const QVariant &value, int role = Qt::EditRole) override {
    if (index.isValid() && index.row() >= 0 && index.row() < dataList.size() && role == Qt::EditRole) {
      dataList[index.row()] = value.toString();
      emit dataChanged(index, index, {role}); // 通知视图数据已更改
      return true;
    }
    return false;
  }
#+END_SRC

* Qt 创建 blur 效果给窗口
[2025-06-26 四 19:04]
#+begin_src C++
engine.load(url);

  auto root = engine.rootObjects().at(0);
  QQuickWindow *win = root->findChild<QQuickWindow*>();

  int x = 0;
  int y = 0;
  int width = 640;
  int height = 200;
  int radius = 14;

  QPainterPath path;
  path.addRoundedRect(x, y, width, height, radius, radius);

  QRegion region(path.toFillPolygon().toPolygon());

  // 设置窗口的区域
  // win->setMask(region);

  KWindowEffects::enableBlurBehind(win->winId(), true, region);
#+end_src

* Qt qml 按钮动画。
[2025-06-28 六 16:51]
#+begin_src qml
import QtQuick 2.15
import QtQuick.Window 2.15
import QtQuick.Controls 2.15

Button {
    id: button

    width: 336
    height: 44

    background: Rectangle {
        width: button.width
	height: button.height

        opacity: enabled ? 1 : 0.3

	radius: 8

        color: "white"
    }  // Rectangle

    contentItem: Text {
	anchors.left: parent.left
	anchors.verticalCenter: parent.verticalCenter
	anchors.margins: 16

	font.pointSize: 16

	text: button.text
    }  // Text

    onPressed: anim.start()

    SequentialAnimation {
        id: anim

        // Expand the button
        PropertyAnimation {
            target: button
            property: "scale"
            to: 1.2
            duration: 200
            easing.type: Easing.InOutQuad
        }  // PropertyAnimation

        // Shrink back to normal
        PropertyAnimation {
            target: button
            property: "scale"
            to: 1.0
            duration: 200
            easing.type: Easing.InOutQuad
        }  // PropertyAnimation
    }  // SequentialAnimation($anim)
}  // Button($button)
#+end_src

* Qt qml rounded image
[2025-06-30 一 10:13]
#+BEGIN_SRC qml
  Image {
      id: img
      anchors.fill: parent
      source: modelData

      property bool rounded: true
      property bool adapt: true
      property var radius: 8

      layer.enabled: rounded
      layer.effect: OpacityMask {
  	maskSource: Item {
  	    width: img.width
  	    height: img.height
  	    Rectangle {
  		anchors.centerIn: parent
  		width: img.adapt ? img.width : Math.min(img.width, img.height)
  		height: img.adapt ? img.height : width
  		radius: 8
  	    }
  	}  // Item
      }  // OpacityMask
  }  // Image($img)
#+END_SRC

* C++ 递归创建目录
[2025-07-08 二 14:13]
#+BEGIN_SRC C++
  bool create_directory(const std::string& directory) {
    try {
      std::filesystem::create_directories(directory);
      return true;
    } catch (const std::exception &e) {
      std::cout << "[error] kdm_pkg::create_directory std::exception = " << e.what()  << std::endl;
      return false;
    }

    std::cout << "[error] kdm_pkg::create_directory failed to create directory = " << directory << std::endl;
    return false;
  }
#+END_SRC

* CMake 模板
[2025-07-14 一 10:25]
#+BEGIN_SRC cmake
  cmake_minimum_required(VERSION 3.16)

  # Set the project name and version
  project(kt-llm VERSION 1.0)

  # Specify the C++ standard
  set(CMAKE_CXX_STANDARD 17)
  set(CMAKE_CXX_STANDARD_REQUIRED True)

  # Add the executable
  add_library(${PROJECT_NAME} SHARED
    src/llm_creator.cc
  )

  # Optionally, you can include directories
  target_include_directories(${PROJECT_NAME} PRIVATE
    include)

  # Apply common flags
  target_compile_options(${PROJECT_NAME} PRIVATE
    -Wall -Wextra
    $<$<CONFIG:Debug>:-g -O0>
    $<$<CONFIG:Release>:-O2>)

  # Optionally, you can link libraries
  # target_link_libraries(MyExecutable PRIVATE some_library)
#+END_SRC

* Bash 脚本里获取当前脚本路径
[2025-07-31 四 09:45]
#+BEGIN_SRC bash
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
#+END_SRC

* OpenGL 流光 shader
[2025-07-31 四 10:55]
#+begin_src glsl
#version 330 core
in vec2 fragTexCoord;

uniform sampler2D u_texture;

uniform float u_time;
uniform float u_speed;
uniform float u_intensity;
uniform float u_edgeThickness;
uniform vec3 u_glowColor;

void main() {
    // 获取原始纹理颜色
    vec4 texColor = texture2D(u_texture, fragTexCoord);

    // 更精确的边缘检测
    vec2 texelSize = vec2(u_edgeThickness) / textureSize(u_texture, 0);
    texelSize *= 2.0;
    
    // 检查透明度边缘
    float alpha = texColor.a;
    float alphaUp = texture2D(u_texture, fragTexCoord + vec2(0.0, texelSize.y)).a;
    float alphaDown = texture2D(u_texture, fragTexCoord - vec2(0.0, texelSize.y)).a;
    float alphaLeft = texture2D(u_texture, fragTexCoord - vec2(texelSize.x, 0.0)).a;
    float alphaRight = texture2D(u_texture, fragTexCoord + vec2(texelSize.x, 0.0)).a;

    // 计算透明度变化 (用于透明图片)
    float alphaEdge = abs(alpha - alphaUp) + abs(alpha - alphaDown) + 
                      abs(alpha - alphaLeft) + abs(alpha - alphaRight);
    
    // 检查亮度边缘 (用于不透明图片)
    float luma = dot(texColor.rgb, vec3(0.299, 0.587, 0.114));
    float lumaUp = dot(texture2D(u_texture, fragTexCoord + vec2(0.0, texelSize.y)).rgb, vec3(0.299, 0.587, 0.114));
    float lumaDown = dot(texture2D(u_texture, fragTexCoord - vec2(0.0, texelSize.y)).rgb, vec3(0.299, 0.587, 0.114));
    float lumaLeft = dot(texture2D(u_texture, fragTexCoord - vec2(texelSize.x, 0.0)).rgb, vec3(0.299, 0.587, 0.114));
    float lumaRight = dot(texture2D(u_texture, fragTexCoord + vec2(texelSize.x, 0.0)).rgb, vec3(0.299, 0.587, 0.114));
    
    float lumaEdge = abs(luma - lumaUp) + abs(luma - lumaDown) + 
                     abs(luma - lumaLeft) + abs(luma - lumaRight);
    
    // 组合边缘检测 - 取较大值
    float edge = max(alphaEdge * 4.0, lumaEdge * 2.0);
    edge = alphaEdge * 4.0;
    edge = clamp(edge, 0.0, 1.0);

    // 来回移动的流光效果
    float timeVar = u_time * u_speed * 0.05; // 降低速度让来回效果更明显
    float pingPongTime = abs(fract(timeVar * 0.5) * 2.0 - 1.0); // 创建0->1->0的来回效果
    float lightPos = pingPongTime; // 流光位置在0和1之间来回
    float lightWidth = 0.3; // 流光宽度
    
    // 计算当前像素与流光的距离
    float distToLight = abs(fragTexCoord.x - lightPos);
    
    // 创建流光强度，使用平滑过渡
    float lightIntensity = 1.0 - smoothstep(0.0, lightWidth, distToLight);
    lightIntensity = pow(lightIntensity, 2.0); // 让流光更聚焦
    
    // 最终的发光效果
    vec3 glow = u_glowColor * edge * u_intensity * lightIntensity;

    // 混合原始颜色和流光效果
    vec3 finalColor = texColor.rgb + glow;

    gl_FragColor = vec4(finalColor, texColor.a);
}
#+end_src

* OpenGL shader 只保留边缘流光
[2025-07-31 四 15:11]

#+begin_src glsl
#version 330 core
in vec2 fragTexCoord;

uniform sampler2D u_texture;

uniform float u_time;
uniform float u_speed;
uniform float u_intensity;
uniform float u_edgeThickness;
uniform vec3 u_glowColor;

void main() {
    // 获取原始纹理颜色
    vec4 texColor = texture2D(u_texture, fragTexCoord);

    // 更精确的边缘检测
    vec2 texelSize = vec2(u_edgeThickness) / textureSize(u_texture, 0);
    texelSize *= 2.0;
    
    // 检查透明度边缘
    float alpha = texColor.a;
    float alphaUp = texture2D(u_texture, fragTexCoord + vec2(0.0, texelSize.y)).a;
    float alphaDown = texture2D(u_texture, fragTexCoord - vec2(0.0, texelSize.y)).a;
    float alphaLeft = texture2D(u_texture, fragTexCoord - vec2(texelSize.x, 0.0)).a;
    float alphaRight = texture2D(u_texture, fragTexCoord + vec2(texelSize.x, 0.0)).a;

    // 计算透明度变化 (用于透明图片)
    float alphaEdge = abs(alpha - alphaUp) + abs(alpha - alphaDown) + 
                      abs(alpha - alphaLeft) + abs(alpha - alphaRight);
    
    // 检查亮度边缘 (用于不透明图片)
    float luma = dot(texColor.rgb, vec3(0.299, 0.587, 0.114));
    float lumaUp = dot(texture2D(u_texture, fragTexCoord + vec2(0.0, texelSize.y)).rgb, vec3(0.299, 0.587, 0.114));
    float lumaDown = dot(texture2D(u_texture, fragTexCoord - vec2(0.0, texelSize.y)).rgb, vec3(0.299, 0.587, 0.114));
    float lumaLeft = dot(texture2D(u_texture, fragTexCoord - vec2(texelSize.x, 0.0)).rgb, vec3(0.299, 0.587, 0.114));
    float lumaRight = dot(texture2D(u_texture, fragTexCoord + vec2(texelSize.x, 0.0)).rgb, vec3(0.299, 0.587, 0.114));
    
    float lumaEdge = abs(luma - lumaUp) + abs(luma - lumaDown) + 
                     abs(luma - lumaLeft) + abs(luma - lumaRight);
    
    // 组合边缘检测 - 取较大值
    float edge = max(alphaEdge * 4.0, lumaEdge * 2.0);
    edge = alphaEdge * 4.0;
    edge = clamp(edge, 0.0, 1.0);

    // 来回移动的流光效果
    float timeVar = u_time * u_speed * 0.05; // 降低速度让来回效果更明显
    float pingPongTime = abs(fract(timeVar * 0.5) * 2.0 - 1.0); // 创建0->1->0的来回效果
    float lightPos = pingPongTime; // 流光位置在0和1之间来回
    float lightWidth = 0.3; // 流光宽度
    
    // 计算当前像素与流光的距离
    float distToLight = abs(fragTexCoord.x - lightPos);
    
    // 创建流光强度，使用平滑过渡
    float lightIntensity = 1.0 - smoothstep(0.0, lightWidth, distToLight);
    lightIntensity = pow(lightIntensity, 2.0); // 让流光更聚焦
    
    // 最终的发光效果
    vec4 glow = vec4(u_glowColor, texColor.a) * edge * u_intensity * lightIntensity;

    // 只要边缘流光
    vec4 finalColor = glow;

    gl_FragColor = finalColor;
}
#+end_src

* Linux 获取用户目录
<2025-08-15 五>
#+begin_src bash
  xdg-user-dir DESKTOP
  DESKTOP_DIR=$(xdg-user-dir DESKTOP)
#+end_src
这个命令会返回当前用户的桌面文件夹的完整路径，无论系统语言是中文还是英文。

* FP32、FP64
FP 指的是 Floating-Point 。

* AVX-512
AVX-512 are 512-bit extensions to the 256-bit Advanced Vector Extensions SIMD instructions for x86 instruction set architecture proposed by Intel in July 2013, and first implemented in the 2016 Intel Xeon Phi x200, and then later in a number of AMD and other Intel CPUs. AVX-512 consists of multiple extensions that may be implemented independently. This policy is a departure from the historical requirement of implementing the entire instruction block.

* AMX
Advanced Matrix Extensions (AMX), also known as Intel Advanced Matrix Extensions (Intel AMX), are extensions to the x86 instruction set architecture (ISA) for microprocessors from Intel designed to work on matrices to accelerate artificial intelligence (AI) and machine learning (ML) workloads.

* Qt 获取屏幕大小
#+begin_src C++
  QScreen *screen = QGuiApplication::primaryScreen();
  QSize screen_size = screen->availableSize();
#+end_src

* C 语言对数组取地址结果不变
#+begin_src C
  #include <stdio.h>

  int main() {
          char arr[5] = { 0 };  // &arr == arr

          printf(":)\n");

          return 0;
  }
#+end_src

* C/C++ static 会自动初始化为 0
#+begin_src C
   #include <stdio.h>

   static int test;

   int main() {
           printf("test: %d\n", test);
           return 0;
   }

   /*
     output: test: 0
   */
#+end_src

* Qt DBus 链接信号如果签名未知应该用 QDBusMessage
#+begin_src C++
  bool connected = QDBusConnection::systemBus().connect(
      "",
      "",
      // "org.powertop.service",
      // "/org/powertop/service",
      "org.powertop.service",
      "ProcessPowerEstChanged",
      this,
      SLOT(OnMessageReceived(const QDBusMessage &)));

  void ProcessPowerMonitor::OnMessageReceived(const QDBusMessage &message) {
    qDebug() << __PRETTY_FUNCTION__ << message.arguments().size();

    if (message.arguments().isEmpty())
      return;

    QVariant var = message.arguments().first();
    if (!var.canConvert<QDBusArgument>())
      return;

    QDBusArgument arg = var.value<QDBusArgument>();

    QList<QVariantMap> result;

    arg.beginArray();
    while (!arg.atEnd()) {
      QVariantMap item;

      arg >> item;

      result.append(item);
    }
    arg.endArray();

    qDebug() << "result size:" << result.size();

    for (const QVariantMap &map : result) {
      qDebug() << map;
    }
  }
#+end_src

* qml 无边框窗口阴影实现方案
#+begin_src qml
  import QtQuick 2.15
  import QtQuick.Window 2.15

  Window {
      width: 400
      height: 300

      visible: true

      color: "white"
      flags: Qt.FramelessWindowHint | Qt.WindowStaysOnTopHint

      Canvas {
  	id: shadowCanvas
  	
  	property real cornerRadius: 10

  	anchors.fill: parent

  	antialiasing: true
  	
  	onPaint: {
              var ctx = getContext("2d")
              ctx.clearRect(0, 0, width, height)
              
              // 绘制圆角矩形函数
              function drawRoundedRect(x, y, width, height, radius) {
  		ctx.beginPath()
  		ctx.moveTo(x + radius, y)
  		ctx.lineTo(x + width - radius, y)
  		ctx.arcTo(x + width, y, x + width, y + radius, radius)
  		ctx.lineTo(x + width, y + height - radius)
  		ctx.arcTo(x + width, y + height, x + width - radius, y + height, radius)
  		ctx.lineTo(x + radius, y + height)
  		ctx.arcTo(x, y + height, x, y + height - radius, radius)
  		ctx.lineTo(x, y + radius)
  		ctx.arcTo(x, y, x + radius, y, radius)
  		ctx.closePath()
              }
              
              // 先绘制所有阴影
              for (var i = 0; i < 10; i++) {
  		var offset = 10 - i
  		var rectWidth = width - offset * 2
  		var rectHeight = height - offset * 2
  		
  		// 调整阴影的圆角半径，使其随着阴影层变化
  		var shadowRadius = cornerRadius + i
  		// shadowRadius = 0
  		
  		var alpha = 150 - Math.sqrt(i) * 50
  		var color = "rgba(0, 0, 0, " + (alpha / 255) + ")"
  		
  		ctx.strokeStyle = color
  		ctx.lineWidth = 1
  		
  		drawRoundedRect(offset, offset, rectWidth, rectHeight, shadowRadius)

  		console.debug(offset, offset, rectWidth, rectHeight)
  		ctx.stroke()
              }
              
              // 最后绘制白色填充矩形
              // ctx.fillStyle = "white"
              // drawRoundedRect(10, 10, width - 20, height - 20, cornerRadius)
              // ctx.fill()
  	}
  	
  	onWidthChanged: requestPaint()
  	onHeightChanged: requestPaint()
      }

  }

#+end_src

* 库搜索的时候，会自动查找相关依赖，run path 取决于被需要的二进制。
#+begin_src bash
  57019:	file=libc.so.6 [0];  needed by ./xiaotian [0]
  57019:	find library=libc.so.6 [0]; searching
  57019:	 search path=/opt/apps/com.lenovo.kedge/vcpkg_installed/x64-linux/lib:/opt/apps/com.lenovo.kedge/lib:/home/yangsiyu/Qt/5.15.2/gcc_64/lib:/home/yangsiyu/QtProjs/temp/ai-mouse/build/printer		(RUNPATH from file ./xiaotian)
  57019:	  trying file=/opt/apps/com.lenovo.kedge/vcpkg_installed/x64-linux/lib/libc.so.6
  57019:	  trying file=/opt/apps/com.lenovo.kedge/lib/libc.so.6
  57019:	  trying file=/home/yangsiyu/Qt/5.15.2/gcc_64/lib/libc.so.6
  57019:	  trying file=/home/yangsiyu/QtProjs/temp/ai-mouse/build/printer/libc.so.6
  57019:	 search cache=/etc/ld.so.cache
  57019:	  trying file=/lib/x86_64-linux-gnu/libc.so.6
  57019:	
  57019:	file=libc.so.6 [0];  generating link map
  57019:	  dynamic: 0x00007f939869db80  base: 0x00007f93984bd000   size: 0x00000000001e6660
  57019:	    entry: 0x00007f93984e1450  phdr: 0x00007f93984bd040  phnum:                 14
  57019:	
  57019:	
  57019:	file=liblogger.so [0];  needed by /opt/apps/com.lenovo.kedge/lib/libgrpcbase.so [0]
  57019:	find library=liblogger.so [0]; searching
  57019:	 search cache=/etc/ld.so.cache
  57019:	 search path=/lib/x86_64-linux-gnu/tls/haswell/x86_64:/lib/x86_64-linux-gnu/tls/haswell:/lib/x86_64-linux-gnu/tls/x86_64:/lib/x86_64-linux-gnu/tls:/lib/x86_64-linux-gnu/haswell/x86_64:/lib/x86_64-linux-gnu/haswell:/lib/x86_64-linux-gnu/x86_64:/lib/x86_64-linux-gnu:/usr/lib/x86_64-linux-gnu/tls/haswell/x86_64:/usr/lib/x86_64-linux-gnu/tls/haswell:/usr/lib/x86_64-linux-gnu/tls/x86_64:/usr/lib/x86_64-linux-gnu/tls:/usr/lib/x86_64-linux-gnu/haswell/x86_64:/usr/lib/x86_64-linux-gnu/haswell:/usr/lib/x86_64-linux-gnu/x86_64:/usr/lib/x86_64-linux-gnu:/lib/tls/haswell/x86_64:/lib/tls/haswell:/lib/tls/x86_64:/lib/tls:/lib/haswell/x86_64:/lib/haswell:/lib/x86_64:/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib		(system search path)
  57019:	  trying file=/lib/x86_64-linux-gnu/tls/haswell/x86_64/liblogger.so
  57019:	  trying file=/lib/x86_64-linux-gnu/tls/haswell/liblogger.so
  57019:	  trying file=/lib/x86_64-linux-gnu/tls/x86_64/liblogger.so
  57019:	  trying file=/lib/x86_64-linux-gnu/tls/liblogger.so
  57019:	  trying file=/lib/x86_64-linux-gnu/haswell/x86_64/liblogger.so
  57019:	  trying file=/lib/x86_64-linux-gnu/haswell/liblogger.so
  57019:	  trying file=/lib/x86_64-linux-gnu/x86_64/liblogger.so
  57019:	  trying file=/lib/x86_64-linux-gnu/liblogger.so
  57019:	  trying file=/usr/lib/x86_64-linux-gnu/tls/haswell/x86_64/liblogger.so
  57019:	  trying file=/usr/lib/x86_64-linux-gnu/tls/haswell/liblogger.so
  57019:	  trying file=/usr/lib/x86_64-linux-gnu/tls/x86_64/liblogger.so
  57019:	  trying file=/usr/lib/x86_64-linux-gnu/tls/liblogger.so
  57019:	  trying file=/usr/lib/x86_64-linux-gnu/haswell/x86_64/liblogger.so
  57019:	  trying file=/usr/lib/x86_64-linux-gnu/haswell/liblogger.so
  57019:	  trying file=/usr/lib/x86_64-linux-gnu/x86_64/liblogger.so
  57019:	  trying file=/usr/lib/x86_64-linux-gnu/liblogger.so
  57019:	  trying file=/lib/tls/haswell/x86_64/liblogger.so
  57019:	  trying file=/lib/tls/haswell/liblogger.so
  57019:	  trying file=/lib/tls/x86_64/liblogger.so
  57019:	  trying file=/lib/tls/liblogger.so
  57019:	  trying file=/lib/haswell/x86_64/liblogger.so
  57019:	  trying file=/lib/haswell/liblogger.so
  57019:	  trying file=/lib/x86_64/liblogger.so
  57019:	  trying file=/lib/liblogger.so
  57019:	  trying file=/usr/lib/tls/haswell/x86_64/liblogger.so
  57019:	  trying file=/usr/lib/tls/haswell/liblogger.so
  57019:	  trying file=/usr/lib/tls/x86_64/liblogger.so
  57019:	  trying file=/usr/lib/tls/liblogger.so
  57019:	  trying file=/usr/lib/haswell/x86_64/liblogger.so
  57019:	  trying file=/usr/lib/haswell/liblogger.so
  57019:	  trying file=/usr/lib/x86_64/liblogger.so
  57019:	  trying file=/usr/lib/liblogger.so
  57019:	
#+end_src
