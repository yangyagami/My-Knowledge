* C++ 读取文件内容到容器里
[2025-06-10 二 17:09]
#+BEGIN_SRC C++
std::string inputBuffer((std::istreambuf_iterator<char>(file)),
                          std::istreambuf_iterator<char>());
#+END_SRC

* qml 监听并且设置快捷键
[2025-06-11 三 15:57]
#+BEGIN_SRC qml
  Button {
      id: toggleWakeup
      anchors.right: parent.right
      anchors.verticalCenter: parent.verticalCenter
      text: "点击我或按 Ctrl+S"
      onClicked: {
  	toggleWakeup.text = "按钮被点击或 Ctrl+S 被按下";
      }

      Keys.onPressed: {
  	if (event.modifiers & Qt.ControlModifier && event.key === Qt.Key_S) {
  	    toggleWakeup.text = "你按下了 Ctrl+S";
  	    event.accepted = true;
  	}
      }
  }  // Button($toggleWakeup)
=======
* HTML 创建按钮，并且监听 onclick 事件
[2025-05-15 Thu 10:51]
#+BEGIN_SRC js
  const button = document.createElement('button');
  button.innerText = '带我去';

  button.onclick = function() {
      
  };
#+END_SRC

* HTML CSS 隐藏滚动条
[2025-05-15 Thu 14:13]
#+BEGIN_SRC css
  /* 隐藏滚动条 */
  .chat-container::-webkit-scrollbar {
      display: none; /* 对于 WebKit 浏览器（Chrome, Safari） */
  }
#+END_SRC

* std::shared_ptr 模板参数不用带星号。
[2025-05-18 Sun 10:44]
#+BEGIN_SRC C++
std::shared_ptr<BaiduFaceApi> api_ = nullptr;
#+END_SRC

* shared_ptr 这样构造。
[2025-05-18 Sun 10:49]
#+BEGIN_SRC C++
api_ = std::make_shared<BaiduFaceApi>();
#+END_SRC

* QRect 设置 Rect 。
[2025-05-18 Sun 13:14]
#+BEGIN_SRC C++
  stImageResult.face_rgb_rect.setRect(
      faces[0].left,
      faces[0].top,
      faces[0].right,
      faces[0].bottom);
#+END_SRC

* QDir::homePath
非 windows 系统下，使用 HOME 环境变量获取。

* QT 绘制无线信号
[2025-05-22 Thu 15:58]
#+BEGIN_SRC C++
  #ifndef RK3588_WIFI_WIFI_DELEGATE_H_
  #define RK3588_WIFI_WIFI_DELEGATE_H_

  #include <QStyledItemDelegate>
  #include <QPainter>
  #include <QDebug>
  #include <QPainterPath>

  #include "wifi_model.h"

  class RK3588WifiDelegate : public QStyledItemDelegate {
   public:
    using QStyledItemDelegate::QStyledItemDelegate;

    // 自定义绘制函数
    void paint(QPainter* painter,
               const QStyleOptionViewItem& option,
               const QModelIndex& index) const override {

      painter->save();

      painter->setRenderHint(QPainter::Antialiasing);

      // painter->translate(option.rect.topLeft());

      // 高亮选中项的背景
      if (option.state & QStyle::State_Selected) {
        painter->fillRect(option.rect, QColor("#e3f2fd")); // 浅蓝色背景
      }

      // 绘制文本（左对齐，垂直居中）
      QFont font;

      font.setPointSize(12);

      painter->setFont(font);

      QString text = index.data(RK3588WifiModel::kSSID).toString();
      QRect textRect = option.rect.adjusted(5, 0, -5, 0); // 左右留空5像素

      painter->setPen(Qt::black);
      painter->drawText(textRect, Qt::AlignLeft | Qt::AlignVCenter, text);

      DrawWifi(painter, option, index);

      painter->restore();
    }

    // 设置项的理想大小
    QSize sizeHint(const QStyleOptionViewItem& option,
                   const QModelIndex& index) const override {
      return QSize(option.widget->width(), 80);
    }

   private:
    void DrawWifiArc(QPainter* painter, int radius, int arc_height,
                     bool sub = true) const {
      // Center rect. radius = rect.width / 2; also as circle's radius.
      QRectF rect(-radius, -radius, radius << 1, radius << 1);

      QPainterPath path;
      path.arcTo(rect, 45, 90);

      QPainterPath subPath;
      subPath.addEllipse(
          rect.adjusted(arc_height, arc_height, -arc_height, -arc_height));

      if (sub) {
        path -= subPath;
      }
      painter->drawPath(path);
    }

    void DrawWifi(QPainter* painter,
                  const QStyleOptionViewItem& option,
                  const QModelIndex& index) const {
      int signal = index.data(RK3588WifiModel::kSignal).toInt();

      QRect wifi_rect = option.rect.adjusted(
          option.rect.width() - 120,
          20,
          -90,
          -20);

      const int kMaxItem = 4;

      const int kRadius = wifi_rect.height() * 0.88;
      const int kArcHeight = wifi_rect.height() / 10.5;

      for (int i = 0; i < kMaxItem; ++i) {
        if (signal >= i) {
          // Has signal
          painter->setPen(Qt::black);
          painter->setBrush(Qt::black);
        } else {
          painter->setPen(QColor(200, 200, 200));
          painter->setBrush(QColor(200, 200, 200));
        }

        switch (i) {
          case 0: {
            painter->translate(
                QPointF(wifi_rect.x() + wifi_rect.width() * 0.5,
                        wifi_rect.y() + wifi_rect.height() * 0.95));
            DrawWifiArc(painter, kRadius * 0.15, kArcHeight, false);
            break;
          }
          case 1:
            DrawWifiArc(painter, kRadius * 0.4, kArcHeight);
            break;
          case 2:
            DrawWifiArc(painter, kRadius * 0.7, kArcHeight);
            break;
          case 3:
            DrawWifiArc(painter, kRadius, kArcHeight);
            break;
        }
      }
    }
  };

  #endif  // RK3588_WIFI_WIFI_DELEGATE_H_
#+END_SRC

* QT 遍历 QJsonArray
[2025-05-25 Sun 11:25]
#+BEGIN_SRC C++
  QJsonArray json_array = doc.array();
  for (const QJsonValue &value : json_array) {
      qDebug() << value; // 处理每个值
  }
#+END_SRC

* QT 图像被莫名翻转
[2025-05-25 Sun 17:09]
#+BEGIN_SRC C++
  // 图片文件（如 JPEG）可能包含 EXIF 方向标签（Orientation Tag），部分图像库（如 Qt 的默认图像加载器）不会自动处理此信息，导致图像显示时方向错误。
QImageReader reader(path);
  reader.setAutoTransform(true); // 启用自动 EXIF 方向校正
  QImage image = reader.read();
#+END_SRC

* QT 信号重载
[2025-05-27 Tue 11:54]
#+BEGIN_SRC C++
  connect(ws_, QOverload<QAbstractSocket::SocketError>::of(&QWebSocket::error),
  [this](QAbstractSocket::SocketError error){
              QString error_str =
                  QMetaEnum::fromType<QAbstractSocket::SocketError>()
                  .valueToKey(error);
              logger_.Error(QString("Network error: %1").arg(error_str));
              emit AiControllerStatusNotify(static_cast<int>(error) + 7000,
                                            "Network error.");
            });
#+END_SRC

* C++ 计算经过时间
[2025-06-02 Mon 12:35]
#+BEGIN_SRC C++
  auto start = std::chrono::high_resolution_clock::now();
  player.Write(buffer, 3000ms);
  auto end = std::chrono::high_resolution_clock::now();
  // 计算持续时间
  std::chrono::duration<double> duration = end - start;

  // 输出执行时间（秒）
  std::cout << "执行时间: " << duration.count() << " 秒" << std::endl;
#+END_SRC

* QT 读取目录下的文件
[2025-06-16 一 14:16]
#+BEGIN_SRC C++
  QDir dir("/usr/share/applications");
  if (!dir.exists()) {
    qDebug() << "目录不存在";
    return -1;
  }

  QStringList filters;
  filters << "*.desktop"; // 只处理 .desktop 文件
  QFileInfoList files = dir.entryInfoList(filters, QDir::Files);

  QVector<DesktopFile*> desktop_files;

  for (const QFileInfo &fileInfo : files) {
    qDebug() << "解析文件:" << fileInfo.filePath();
    DesktopFile *desktopfile = new DesktopFile;
    if (desktopfile->Parse(fileInfo.filePath())) {
      desktop_files.push_back(desktopfile);
    }
  }
#+END_SRC

* qml listview 自动滚动
[2025-06-18 三 14:17]
#+BEGIN_SRC qml
  ListView {
      id: listmodelId
      width: parent.width
      height: parent.height * 0.6

      clip: true

      onCountChanged: Qt.callLater(scrollToBottom)

      function scrollToBottom() {
    	    if (count > 0) {
    		positionViewAtEnd()
    	    }
      }

      onContentHeightChanged: Qt.callLater(scrollToBottom)  // 滚动时这个也会变化

      spacing: 10
      model: g_chatWindowModel.chatModel
      delegate: CusItemRect {
    	    id: cusitemRectid

    	    itemImgemodel: chatMsgImage
    	    msgText: chatMsgConten
    	    itemUrlmodel: chatMsgUrl
    	    isSelf: chatMsgIsSelf

    	    onHeightChanged: {
    		listmodelId.scrollToBottom()
    	    }
      }

      ScrollBar.vertical: ScrollBar {
    	id: vbar
    	policy: ScrollBar.AsNeeded
    	width: 10

    	contentItem: Rectangle {
              implicitWidth: 6
              radius: 4
              color: vbar.pressed ? "#6c6c6c" : (vbar.hovered ? "#9a9a9a" : "#c4c4c4")
              Behavior on color {
    		ColorAnimation {
                      duration: 100
    		}  // ColorAnimation
              }
    	}  // Rectangle

    	background: Rectangle {
              implicitWidth: 10
              color: "#f0f0f0"
    	}  // Rectangle
      }  // ScrollBar($vbar)
  }  // ListViw($listmodelId)

  // 控制是否自动滚动（例如用户手动滚动时禁用）
  property bool autoScroll: true

  function scrollToBottom() {
      if (autoScroll && count > 0) {
          positionViewAtEnd()
      }
  }

  // 用户交互时暂停自动滚动
  onMovementStarted: autoScroll = false
  onMovementEnded: {
      // 如果在底部附近则恢复自动滚动
      autoScroll = (contentY >= contentHeight - height - 20)
  }
#+END_SRC

* CMake 根据构建模式来设置不同的编译选项
[2025-06-20 五 14:20]
#+BEGIN_SRC cmake
  target_compile_options(${PROJECT_NAME} PRIVATE
    -Wall -Wextra
    $<$<CONFIG:Debug>:-O0>
    $<$<CONFIG:Release>:-O2>
  )

  target_link_libraries(${PROJECT_NAME}
    PRIVATE Qt${QT_VERSION_MAJOR}::Core Qt${QT_VERSION_MAJOR}::Quick Qt${QT_VERSION_MAJOR}::Multimedia Qt${QT_VERSION_MAJOR}::Network
    $<$<CONFIG:Debug>:-fsanitize=address>)
  #+END_SRC

* Qt invokeMethod 使用示例
[2025-06-20 五 14:31]
#+BEGIN_SRC C++
  QMetaObject::invokeMethod(dynamic_cast<PrinterFinderWorker*>(worker_),
                            &PrinterFinderWorker::GetPrinterInfoList);
#+END_SRC

* 热重载 qml 的方法，以及可分别设置圆角方法（Qt5)
[2025-06-21 六 18:43]
#+BEGIN_SRC qml
  使用 qmlpreview
  Window {
      width: 640
      height: 800
      visible: true
      title: qsTr("Hello World")
      flags: Qt.FramelessWindowHint | Qt.WindowStaysOnTopHint | Qt.Popup

      Canvas {
  	id: canvas
  	width: parent.width - 40
  	height: 60
  	x: 20
  	y: 80
  	property var color: Qt.rgba(0, 1, 1, 1)
  	property var radius: [20, 20, 0, 0]  // topLeft topRight bottomLeft bottomRight
  	onPaint:{
              var ctx = canvas.getContext("2d")

  	    ctx.beginPath(); 
  	    ctx.moveTo(0, radius[2]);
  	    ctx.lineTo(0, height - radius[2]);
  	    ctx.arcTo(0, height, radius[2], height, radius[2])
  	    ctx.lineTo(width - radius[3], height)
  	    ctx.arcTo(width, height, width, height - radius[3], radius[3])
  	    ctx.lineTo(width, radius[1])
  	    ctx.arcTo(width, 0, width - radius[1], 0, radius[1])
  	    ctx.lineTo(radius[0], 0)
  	    ctx.arcTo(0, 0, 0, radius[0], radius[0])
  	    ctx.fillStyle = color
  	    ctx.fill();
  	}
      }
  }
#+END_SRC

* Qt model setData 例子
[2025-06-26 四 10:45]
#+BEGIN_SRC C++
  bool setData(const QModelIndex &index, const QVariant &value, int role = Qt::EditRole) override {
    if (index.isValid() && index.row() >= 0 && index.row() < dataList.size() && role == Qt::EditRole) {
      dataList[index.row()] = value.toString();
      emit dataChanged(index, index, {role}); // 通知视图数据已更改
      return true;
    }
    return false;
  }
#+END_SRC

* Qt 创建 blur 效果给窗口
[2025-06-26 四 19:04]
engine.load(url);

  auto root = engine.rootObjects().at(0);
  QQuickWindow *win = root->findChild<QQuickWindow*>();

  int x = 0;
  int y = 0;
  int width = 640;
  int height = 200;
  int radius = 14;

  QPainterPath path;
  path.addRoundedRect(x, y, width, height, radius, radius);

  QRegion region(path.toFillPolygon().toPolygon());

  // 设置窗口的区域
  // win->setMask(region);

  KWindowEffects::enableBlurBehind(win->winId(), true, region);

* Qt qml 按钮动画。
[2025-06-28 六 16:51]
import QtQuick 2.15
import QtQuick.Window 2.15
import QtQuick.Controls 2.15

Button {
    id: button

    width: 336
    height: 44

    background: Rectangle {
        width: button.width
	height: button.height

        opacity: enabled ? 1 : 0.3

	radius: 8

        color: "white"
    }  // Rectangle

    contentItem: Text {
	anchors.left: parent.left
	anchors.verticalCenter: parent.verticalCenter
	anchors.margins: 16

	font.pointSize: 16

	text: button.text
    }  // Text

    onPressed: anim.start()

    SequentialAnimation {
        id: anim

        // Expand the button
        PropertyAnimation {
            target: button
            property: "scale"
            to: 1.2
            duration: 200
            easing.type: Easing.InOutQuad
        }  // PropertyAnimation

        // Shrink back to normal
        PropertyAnimation {
            target: button
            property: "scale"
            to: 1.0
            duration: 200
            easing.type: Easing.InOutQuad
        }  // PropertyAnimation
    }  // SequentialAnimation($anim)
}  // Button($button)

* Qt qml rounded image
[2025-06-30 一 10:13]
#+BEGIN_SRC qml
  Image {
      id: img
      anchors.fill: parent
      source: modelData

      property bool rounded: true
      property bool adapt: true
      property var radius: 8

      layer.enabled: rounded
      layer.effect: OpacityMask {
  	maskSource: Item {
  	    width: img.width
  	    height: img.height
  	    Rectangle {
  		anchors.centerIn: parent
  		width: img.adapt ? img.width : Math.min(img.width, img.height)
  		height: img.adapt ? img.height : width
  		radius: 8
  	    }
  	}  // Item
      }  // OpacityMask
  }  // Image($img)
#+END_SRC

* C++ 递归创建目录
[2025-07-08 二 14:13]
#+BEGIN_SRC C++
  bool create_directory(const std::string& directory) {
    try {
      std::filesystem::create_directories(directory);
      return true;
    } catch (const std::exception &e) {
      std::cout << "[error] kdm_pkg::create_directory std::exception = " << e.what()  << std::endl;
      return false;
    }

    std::cout << "[error] kdm_pkg::create_directory failed to create directory = " << directory << std::endl;
    return false;
  }
#+END_SRC

* CMake 模板
[2025-07-14 一 10:25]
#+BEGIN_SRC cmake
  cmake_minimum_required(VERSION 3.16)

  # Set the project name and version
  project(kt-llm VERSION 1.0)

  # Specify the C++ standard
  set(CMAKE_CXX_STANDARD 17)
  set(CMAKE_CXX_STANDARD_REQUIRED True)

  # Add the executable
  add_library(${PROJECT_NAME} SHARED
    src/llm_creator.cc
  )

  # Optionally, you can include directories
  target_include_directories(${PROJECT_NAME} PRIVATE
    include)

  # Apply common flags
  target_compile_options(${PROJECT_NAME} PRIVATE
    -Wall -Wextra
    $<$<CONFIG:Debug>:-g -O0>
    $<$<CONFIG:Release>:-O2>)

  # Optionally, you can link libraries
  # target_link_libraries(MyExecutable PRIVATE some_library)
#+END_SRC

* Bash 脚本里获取当前脚本路径
[2025-07-31 四 09:45]
#+BEGIN_SRC bash
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
#+END_SRC

* OpenGL 流光 shader
[2025-07-31 四 10:55]
#+begin_src glsl
#version 330 core
in vec2 fragTexCoord;

uniform sampler2D u_texture;

uniform float u_time;
uniform float u_speed;
uniform float u_intensity;
uniform float u_edgeThickness;
uniform vec3 u_glowColor;

void main() {
    // 获取原始纹理颜色
    vec4 texColor = texture2D(u_texture, fragTexCoord);

    // 更精确的边缘检测
    vec2 texelSize = vec2(u_edgeThickness) / textureSize(u_texture, 0);
    texelSize *= 2.0;
    
    // 检查透明度边缘
    float alpha = texColor.a;
    float alphaUp = texture2D(u_texture, fragTexCoord + vec2(0.0, texelSize.y)).a;
    float alphaDown = texture2D(u_texture, fragTexCoord - vec2(0.0, texelSize.y)).a;
    float alphaLeft = texture2D(u_texture, fragTexCoord - vec2(texelSize.x, 0.0)).a;
    float alphaRight = texture2D(u_texture, fragTexCoord + vec2(texelSize.x, 0.0)).a;

    // 计算透明度变化 (用于透明图片)
    float alphaEdge = abs(alpha - alphaUp) + abs(alpha - alphaDown) + 
                      abs(alpha - alphaLeft) + abs(alpha - alphaRight);
    
    // 检查亮度边缘 (用于不透明图片)
    float luma = dot(texColor.rgb, vec3(0.299, 0.587, 0.114));
    float lumaUp = dot(texture2D(u_texture, fragTexCoord + vec2(0.0, texelSize.y)).rgb, vec3(0.299, 0.587, 0.114));
    float lumaDown = dot(texture2D(u_texture, fragTexCoord - vec2(0.0, texelSize.y)).rgb, vec3(0.299, 0.587, 0.114));
    float lumaLeft = dot(texture2D(u_texture, fragTexCoord - vec2(texelSize.x, 0.0)).rgb, vec3(0.299, 0.587, 0.114));
    float lumaRight = dot(texture2D(u_texture, fragTexCoord + vec2(texelSize.x, 0.0)).rgb, vec3(0.299, 0.587, 0.114));
    
    float lumaEdge = abs(luma - lumaUp) + abs(luma - lumaDown) + 
                     abs(luma - lumaLeft) + abs(luma - lumaRight);
    
    // 组合边缘检测 - 取较大值
    float edge = max(alphaEdge * 4.0, lumaEdge * 2.0);
    edge = alphaEdge * 4.0;
    edge = clamp(edge, 0.0, 1.0);

    // 来回移动的流光效果
    float timeVar = u_time * u_speed * 0.05; // 降低速度让来回效果更明显
    float pingPongTime = abs(fract(timeVar * 0.5) * 2.0 - 1.0); // 创建0->1->0的来回效果
    float lightPos = pingPongTime; // 流光位置在0和1之间来回
    float lightWidth = 0.3; // 流光宽度
    
    // 计算当前像素与流光的距离
    float distToLight = abs(fragTexCoord.x - lightPos);
    
    // 创建流光强度，使用平滑过渡
    float lightIntensity = 1.0 - smoothstep(0.0, lightWidth, distToLight);
    lightIntensity = pow(lightIntensity, 2.0); // 让流光更聚焦
    
    // 最终的发光效果
    vec3 glow = u_glowColor * edge * u_intensity * lightIntensity;

    // 混合原始颜色和流光效果
    vec3 finalColor = texColor.rgb + glow;

    gl_FragColor = vec4(finalColor, texColor.a);
}
#+end_src

* OpenGL shader 只保留边缘流光
[2025-07-31 四 15:11]

#+begin_src glsl
#version 330 core
in vec2 fragTexCoord;

uniform sampler2D u_texture;

uniform float u_time;
uniform float u_speed;
uniform float u_intensity;
uniform float u_edgeThickness;
uniform vec3 u_glowColor;

void main() {
    // 获取原始纹理颜色
    vec4 texColor = texture2D(u_texture, fragTexCoord);

    // 更精确的边缘检测
    vec2 texelSize = vec2(u_edgeThickness) / textureSize(u_texture, 0);
    texelSize *= 2.0;
    
    // 检查透明度边缘
    float alpha = texColor.a;
    float alphaUp = texture2D(u_texture, fragTexCoord + vec2(0.0, texelSize.y)).a;
    float alphaDown = texture2D(u_texture, fragTexCoord - vec2(0.0, texelSize.y)).a;
    float alphaLeft = texture2D(u_texture, fragTexCoord - vec2(texelSize.x, 0.0)).a;
    float alphaRight = texture2D(u_texture, fragTexCoord + vec2(texelSize.x, 0.0)).a;

    // 计算透明度变化 (用于透明图片)
    float alphaEdge = abs(alpha - alphaUp) + abs(alpha - alphaDown) + 
                      abs(alpha - alphaLeft) + abs(alpha - alphaRight);
    
    // 检查亮度边缘 (用于不透明图片)
    float luma = dot(texColor.rgb, vec3(0.299, 0.587, 0.114));
    float lumaUp = dot(texture2D(u_texture, fragTexCoord + vec2(0.0, texelSize.y)).rgb, vec3(0.299, 0.587, 0.114));
    float lumaDown = dot(texture2D(u_texture, fragTexCoord - vec2(0.0, texelSize.y)).rgb, vec3(0.299, 0.587, 0.114));
    float lumaLeft = dot(texture2D(u_texture, fragTexCoord - vec2(texelSize.x, 0.0)).rgb, vec3(0.299, 0.587, 0.114));
    float lumaRight = dot(texture2D(u_texture, fragTexCoord + vec2(texelSize.x, 0.0)).rgb, vec3(0.299, 0.587, 0.114));
    
    float lumaEdge = abs(luma - lumaUp) + abs(luma - lumaDown) + 
                     abs(luma - lumaLeft) + abs(luma - lumaRight);
    
    // 组合边缘检测 - 取较大值
    float edge = max(alphaEdge * 4.0, lumaEdge * 2.0);
    edge = alphaEdge * 4.0;
    edge = clamp(edge, 0.0, 1.0);

    // 来回移动的流光效果
    float timeVar = u_time * u_speed * 0.05; // 降低速度让来回效果更明显
    float pingPongTime = abs(fract(timeVar * 0.5) * 2.0 - 1.0); // 创建0->1->0的来回效果
    float lightPos = pingPongTime; // 流光位置在0和1之间来回
    float lightWidth = 0.3; // 流光宽度
    
    // 计算当前像素与流光的距离
    float distToLight = abs(fragTexCoord.x - lightPos);
    
    // 创建流光强度，使用平滑过渡
    float lightIntensity = 1.0 - smoothstep(0.0, lightWidth, distToLight);
    lightIntensity = pow(lightIntensity, 2.0); // 让流光更聚焦
    
    // 最终的发光效果
    vec4 glow = vec4(u_glowColor, texColor.a) * edge * u_intensity * lightIntensity;

    // 只要边缘流光
    vec4 finalColor = glow;

    gl_FragColor = finalColor;
}
#+end_src

* Linux 获取用户目录
<2025-08-15 五>
#+begin_src bash
  xdg-user-dir DESKTOP
#+end_src
这个命令会返回当前用户的桌面文件夹的完整路径，无论系统语言是中文还是英文。
